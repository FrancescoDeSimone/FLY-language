/**
 * generated by Xtext 2.13.0
 */
package org.xtext.validation;

import com.google.common.base.Objects;
import com.google.inject.Inject;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.xbase.lib.Extension;
import org.xtext.fLY.ArithmeticExpression;
import org.xtext.fLY.BinaryOperation;
import org.xtext.fLY.FLYPackage;
import org.xtext.fLY.Fly;
import org.xtext.fLY.FunctionDefinition;
import org.xtext.fLY.FunctionReturn;
import org.xtext.fLY.PostfixOperation;
import org.xtext.fLY.UnaryOperation;
import org.xtext.typing.FlyType;
import org.xtext.typing.FlyTypeProvider;
import org.xtext.validation.AbstractFLYValidator;

/**
 * This class contains custom validation rules.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
@SuppressWarnings("all")
public class FLYValidator extends AbstractFLYValidator {
  @Inject
  @Extension
  private FlyTypeProvider _flyTypeProvider;
  
  public final static String FORWARD_REFERENCE = "org.text.fly.ForwardReference";
  
  public final static String WRONG_TYPE = "org.text.fly.WrongType";
  
  public final static String WRONG_ATTR = "org.text.fly.WrongAttribute";
  
  public final static String WRONG_VAL = "org.text.fly.WrongValue";
  
  public final static String DUPLCIATE_VAL = "org.text.fly.DuplicateValue";
  
  public final static String WRONG_RETURN = "org.text.fly.WrongReturn";
  
  public Object checkType(final BinaryOperation e) {
    Object _xifexpression = null;
    boolean _equals = e.getFeature().equals("+");
    if (_equals) {
      final Object left = this.getTypeAndCheckNotNull(e.getLeft(), FLYPackage.Literals.BINARY_OPERATION__LEFT);
      final Object right = this.getTypeAndCheckNotNull(e.getRight(), FLYPackage.Literals.BINARY_OPERATION__RIGHT);
      if (((Objects.equal(left, FlyTypeProvider.intType) || Objects.equal(right, FlyTypeProvider.intType)) || ((!Objects.equal(left, FlyTypeProvider.stringType)) && (!Objects.equal(right, FlyTypeProvider.stringType))))) {
        this.checkNotBoolean(left, FLYPackage.Literals.BINARY_OPERATION__LEFT);
        this.checkNotBoolean(right, FLYPackage.Literals.BINARY_OPERATION__RIGHT);
      }
    } else {
      Object _xifexpression_1 = null;
      if (((e.getFeature().equals("-") || e.getFeature().equals("*")) || e.getFeature().equals("/"))) {
        final Object left_1 = this.getTypeAndCheckNotNull(e.getLeft(), FLYPackage.Literals.BINARY_OPERATION__LEFT);
        final Object right_1 = this.getTypeAndCheckNotNull(e.getRight(), FLYPackage.Literals.BINARY_OPERATION__RIGHT);
        if (((Objects.equal(left_1, FlyTypeProvider.intType) || Objects.equal(right_1, FlyTypeProvider.intType)) || ((!Objects.equal(left_1, FlyTypeProvider.floatType)) && (!Objects.equal(right_1, FlyTypeProvider.floatType))))) {
          this.checkNotBoolean(left_1, FLYPackage.Literals.BINARY_OPERATION__LEFT);
          this.checkNotBoolean(right_1, FLYPackage.Literals.BINARY_OPERATION__RIGHT);
          this.checkNotString(left_1, FLYPackage.Literals.BINARY_OPERATION__LEFT);
          this.checkNotString(right_1, FLYPackage.Literals.BINARY_OPERATION__RIGHT);
        }
      } else {
        Object _xifexpression_2 = null;
        if ((e.getFeature().equals("and") || e.getFeature().equals("or"))) {
          this.checkExpectedBoolean(e.getLeft(), FLYPackage.Literals.BINARY_OPERATION__LEFT);
          this.checkExpectedBoolean(e.getRight(), FLYPackage.Literals.BINARY_OPERATION__RIGHT);
        } else {
          Object _xifexpression_3 = null;
          if ((e.getFeature().equals("==") || e.getFeature().equals("!="))) {
            Object _xblockexpression = null;
            {
              this.getTypeAndCheckNotNull(e.getLeft(), FLYPackage.Literals.BINARY_OPERATION__LEFT);
              _xblockexpression = this.getTypeAndCheckNotNull(e.getRight(), FLYPackage.Literals.BINARY_OPERATION__RIGHT);
            }
            _xifexpression_3 = _xblockexpression;
          } else {
            if ((((e.getFeature().equals(">=") || e.getFeature().equals("<=")) || e.getFeature().equals("<")) || e.getFeature().equals(">"))) {
              final Object left_2 = this.getTypeAndCheckNotNull(e.getLeft(), FLYPackage.Literals.BINARY_OPERATION__LEFT);
              final Object right_2 = this.getTypeAndCheckNotNull(e.getRight(), FLYPackage.Literals.BINARY_OPERATION__RIGHT);
              this.checkNotBoolean(left_2, FLYPackage.Literals.BINARY_OPERATION__LEFT);
              this.checkNotBoolean(right_2, FLYPackage.Literals.BINARY_OPERATION__RIGHT);
            }
          }
          _xifexpression_2 = _xifexpression_3;
        }
        _xifexpression_1 = _xifexpression_2;
      }
      _xifexpression = _xifexpression_1;
    }
    return _xifexpression;
  }
  
  @Check
  public void checkReturn(final FunctionReturn ret) {
    Object parent = this.getParent(ret);
    if ((!(parent instanceof FunctionDefinition))) {
      this.error("the return must be in a function", FLYPackage.Literals.FUNCTION_RETURN__EXPRESSION, FLYValidator.WRONG_RETURN);
    }
  }
  
  private Object getParent(final EObject e) {
    if (((e instanceof FunctionDefinition) || (e instanceof Fly))) {
      return e;
    } else {
      return this.getParent(e.eContainer());
    }
  }
  
  @Check
  public void checkType(final UnaryOperation e) {
    boolean _equals = e.getFeature().equals("!");
    if (_equals) {
      this.checkExpectedBoolean(e.getOperand(), FLYPackage.Literals.UNARY_OPERATION__OPERAND);
    } else {
      ArithmeticExpression _operand = e.getOperand();
      Object _typeFor = null;
      if (_operand!=null) {
        _typeFor=this._flyTypeProvider.typeFor(_operand);
      }
      this.checkNotBoolean(_typeFor, FLYPackage.Literals.POSTFIX_OPERATION__OPERAND);
      ArithmeticExpression _operand_1 = e.getOperand();
      Object _typeFor_1 = null;
      if (_operand_1!=null) {
        _typeFor_1=this._flyTypeProvider.typeFor(_operand_1);
      }
      this.checkNotString(_typeFor_1, FLYPackage.Literals.POSTFIX_OPERATION__OPERAND);
      ArithmeticExpression _operand_2 = e.getOperand();
      Object _typeFor_2 = null;
      if (_operand_2!=null) {
        _typeFor_2=this._flyTypeProvider.typeFor(_operand_2);
      }
      this.checkNotObject(_typeFor_2, FLYPackage.Literals.POSTFIX_OPERATION__OPERAND);
      ArithmeticExpression _operand_3 = e.getOperand();
      Object _typeFor_3 = null;
      if (_operand_3!=null) {
        _typeFor_3=this._flyTypeProvider.typeFor(_operand_3);
      }
      this.checkNotDat(_typeFor_3, FLYPackage.Literals.POSTFIX_OPERATION__OPERAND);
    }
  }
  
  @Check
  public void checkType(final PostfixOperation e) {
    ArithmeticExpression _operand = e.getOperand();
    Object _typeFor = null;
    if (_operand!=null) {
      _typeFor=this._flyTypeProvider.typeFor(_operand);
    }
    this.checkNotBoolean(_typeFor, FLYPackage.Literals.POSTFIX_OPERATION__OPERAND);
    ArithmeticExpression _operand_1 = e.getOperand();
    Object _typeFor_1 = null;
    if (_operand_1!=null) {
      _typeFor_1=this._flyTypeProvider.typeFor(_operand_1);
    }
    this.checkNotString(_typeFor_1, FLYPackage.Literals.POSTFIX_OPERATION__OPERAND);
    ArithmeticExpression _operand_2 = e.getOperand();
    Object _typeFor_2 = null;
    if (_operand_2!=null) {
      _typeFor_2=this._flyTypeProvider.typeFor(_operand_2);
    }
    this.checkNotObject(_typeFor_2, FLYPackage.Literals.POSTFIX_OPERATION__OPERAND);
    ArithmeticExpression _operand_3 = e.getOperand();
    Object _typeFor_3 = null;
    if (_operand_3!=null) {
      _typeFor_3=this._flyTypeProvider.typeFor(_operand_3);
    }
    this.checkNotDat(_typeFor_3, FLYPackage.Literals.POSTFIX_OPERATION__OPERAND);
  }
  
  private void checkExpectedSame(final Object left, final Object right) {
    if ((((!Objects.equal(right, null)) && (!Objects.equal(left, null))) && (!Objects.equal(right, left)))) {
      this.error(((("expected the same type, but was " + left) + ", ") + right), 
        FLYPackage.Literals.BINARY_OPERATION__FEATURE, FLYValidator.WRONG_TYPE);
    }
  }
  
  private void checkNotBoolean(final Object type, final EReference reference) {
    boolean _equals = Objects.equal(type, FlyTypeProvider.boolType);
    if (_equals) {
      this.error("cannot be Boolean", reference, FLYValidator.WRONG_TYPE);
    }
  }
  
  private void checkNotString(final Object type, final EReference reference) {
    boolean _equals = Objects.equal(type, FlyTypeProvider.stringType);
    if (_equals) {
      this.error("cannot be String", reference, FLYValidator.WRONG_TYPE);
    }
  }
  
  private void checkNotObject(final Object type, final EReference reference) {
    boolean _equals = Objects.equal(type, FlyTypeProvider.objectType);
    if (_equals) {
      this.error("cannot be Object", reference, FLYValidator.WRONG_TYPE);
    }
  }
  
  private void checkNotDat(final Object type, final EReference reference) {
    boolean _equals = Objects.equal(type, FlyTypeProvider.datType);
    if (_equals) {
      this.error("cannot be Dat variable", reference, FLYValidator.WRONG_TYPE);
    }
  }
  
  private void checkExpectedType(final ArithmeticExpression exp, final FlyType expectedType, final EReference reference) {
    final Object actualType = this.getTypeAndCheckNotNull(exp, reference);
    boolean _notEquals = (!Objects.equal(actualType, expectedType));
    if (_notEquals) {
      this.error(((("expected " + expectedType) + " type, but was ") + actualType), reference, FLYValidator.WRONG_TYPE);
    }
  }
  
  private void checkExpectedBoolean(final ArithmeticExpression exp, final EReference reference) {
    this.checkExpectedType(exp, FlyTypeProvider.boolType, reference);
  }
  
  private void checkExpectedInt(final ArithmeticExpression exp, final EReference reference) {
    this.checkExpectedType(exp, FlyTypeProvider.intType, reference);
  }
  
  private Object getTypeAndCheckNotNull(final ArithmeticExpression exp, final EReference reference) {
    Object _typeFor = null;
    if (exp!=null) {
      _typeFor=this._flyTypeProvider.typeFor(exp);
    }
    final Object type = _typeFor;
    boolean _equals = Objects.equal(type, null);
    if (_equals) {
      this.error("null type", reference, FLYValidator.WRONG_TYPE);
    }
    return type;
  }
}
