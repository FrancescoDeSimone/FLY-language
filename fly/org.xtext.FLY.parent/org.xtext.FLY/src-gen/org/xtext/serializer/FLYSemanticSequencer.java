/*
 * generated by Xtext 2.15.0
 */
package org.xtext.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.fLY.Assignment;
import org.xtext.fLY.AtomicExpression;
import org.xtext.fLY.BinDeclaration;
import org.xtext.fLY.BinaryOperation;
import org.xtext.fLY.BlockExpression;
import org.xtext.fLY.BooleanLiteral;
import org.xtext.fLY.CastExpression;
import org.xtext.fLY.ChannelDeclaration;
import org.xtext.fLY.ChannelReceive;
import org.xtext.fLY.ChannelSend;
import org.xtext.fLY.DatDeclaration;
import org.xtext.fLY.DatSingleObject;
import org.xtext.fLY.DatTableObject;
import org.xtext.fLY.DeclarationFeature;
import org.xtext.fLY.DeclarationObject;
import org.xtext.fLY.EnvironmentDeclaration;
import org.xtext.fLY.FLYPackage;
import org.xtext.fLY.FeautureName;
import org.xtext.fLY.FloatLiteral;
import org.xtext.fLY.Fly;
import org.xtext.fLY.FlyFunctionCall;
import org.xtext.fLY.ForExpression;
import org.xtext.fLY.FunctionDefinition;
import org.xtext.fLY.FunctionInput;
import org.xtext.fLY.FunctionReturn;
import org.xtext.fLY.IfExpression;
import org.xtext.fLY.IndexObject;
import org.xtext.fLY.LocalFunctionCall;
import org.xtext.fLY.LocalFunctionInput;
import org.xtext.fLY.MathFunction;
import org.xtext.fLY.NameObject;
import org.xtext.fLY.NameObjectDef;
import org.xtext.fLY.NumberLiteral;
import org.xtext.fLY.OptimizerDeclaration;
import org.xtext.fLY.ParenthesizedExpression;
import org.xtext.fLY.PostfixOperation;
import org.xtext.fLY.PrintExpression;
import org.xtext.fLY.RandomDeclaration;
import org.xtext.fLY.RangeLiteral;
import org.xtext.fLY.SortExpression;
import org.xtext.fLY.StringLiteral;
import org.xtext.fLY.TimeFunction;
import org.xtext.fLY.UnaryOperation;
import org.xtext.fLY.VariableDeclaration;
import org.xtext.fLY.VariableFunction;
import org.xtext.fLY.VariableLiteral;
import org.xtext.fLY.WhileExpression;
import org.xtext.services.FLYGrammarAccess;

@SuppressWarnings("all")
public class FLYSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private FLYGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == FLYPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case FLYPackage.ASSIGNMENT:
				sequence_Assignment(context, (Assignment) semanticObject); 
				return; 
			case FLYPackage.ATOMIC_EXPRESSION:
				sequence_AtomicExpression(context, (AtomicExpression) semanticObject); 
				return; 
			case FLYPackage.BIN_DECLARATION:
				sequence_VariableDeclaration(context, (BinDeclaration) semanticObject); 
				return; 
			case FLYPackage.BINARY_OPERATION:
				if (rule == grammarAccess.getArithmeticExpressionRule()
						|| rule == grammarAccess.getOrExpressionRule()
						|| action == grammarAccess.getOrExpressionAccess().getBinaryOperationLeftAction_1_0_0_0()) {
					sequence_AdditiveExpression_AndExpression_EqualityExpression_MultiplicativeExpression_OrExpression_RelationalExpression(context, (BinaryOperation) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getAndExpressionRule()
						|| action == grammarAccess.getAndExpressionAccess().getBinaryOperationLeftAction_1_0_0_0()) {
					sequence_AdditiveExpression_AndExpression_EqualityExpression_MultiplicativeExpression_RelationalExpression(context, (BinaryOperation) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getEqualityExpressionRule()
						|| action == grammarAccess.getEqualityExpressionAccess().getBinaryOperationLeftAction_1_0_0_0()) {
					sequence_AdditiveExpression_EqualityExpression_MultiplicativeExpression_RelationalExpression(context, (BinaryOperation) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getAdditiveExpressionRule()
						|| action == grammarAccess.getAdditiveExpressionAccess().getBinaryOperationLeftAction_1_0_0_0()) {
					sequence_AdditiveExpression_MultiplicativeExpression(context, (BinaryOperation) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getRelationalExpressionRule()
						|| action == grammarAccess.getRelationalExpressionAccess().getBinaryOperationLeftAction_1_0_0_0()) {
					sequence_AdditiveExpression_MultiplicativeExpression_RelationalExpression(context, (BinaryOperation) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getMultiplicativeExpressionRule()
						|| action == grammarAccess.getMultiplicativeExpressionAccess().getBinaryOperationLeftAction_1_0_0_0()) {
					sequence_MultiplicativeExpression(context, (BinaryOperation) semanticObject); 
					return; 
				}
				else break;
			case FLYPackage.BLOCK_EXPRESSION:
				sequence_BlockExpression(context, (BlockExpression) semanticObject); 
				return; 
			case FLYPackage.BOOLEAN_LITERAL:
				sequence_BooleanLiteral(context, (BooleanLiteral) semanticObject); 
				return; 
			case FLYPackage.CAST_EXPRESSION:
				sequence_CastExpression(context, (CastExpression) semanticObject); 
				return; 
			case FLYPackage.CHANNEL_DECLARATION:
				sequence_VariableDeclaration(context, (ChannelDeclaration) semanticObject); 
				return; 
			case FLYPackage.CHANNEL_RECEIVE:
				sequence_ChannelReceive(context, (ChannelReceive) semanticObject); 
				return; 
			case FLYPackage.CHANNEL_SEND:
				sequence_ChannelSend(context, (ChannelSend) semanticObject); 
				return; 
			case FLYPackage.DAT_DECLARATION:
				sequence_VariableDeclaration(context, (DatDeclaration) semanticObject); 
				return; 
			case FLYPackage.DAT_SINGLE_OBJECT:
				sequence_ObjectLiteral(context, (DatSingleObject) semanticObject); 
				return; 
			case FLYPackage.DAT_TABLE_OBJECT:
				sequence_ObjectLiteral(context, (DatTableObject) semanticObject); 
				return; 
			case FLYPackage.DECLARATION_FEATURE:
				sequence_DeclarationFeature(context, (DeclarationFeature) semanticObject); 
				return; 
			case FLYPackage.DECLARATION_OBJECT:
				sequence_DeclarationObject(context, (DeclarationObject) semanticObject); 
				return; 
			case FLYPackage.ENVIRONMENT_DECLARATION:
				sequence_VariableDeclaration(context, (EnvironmentDeclaration) semanticObject); 
				return; 
			case FLYPackage.FEAUTURE_NAME:
				sequence_FeautureName(context, (FeautureName) semanticObject); 
				return; 
			case FLYPackage.FLOAT_LITERAL:
				sequence_FloatLiteral(context, (FloatLiteral) semanticObject); 
				return; 
			case FLYPackage.FLY:
				sequence_Fly(context, (Fly) semanticObject); 
				return; 
			case FLYPackage.FLY_FUNCTION_CALL:
				sequence_FlyFunctionCall(context, (FlyFunctionCall) semanticObject); 
				return; 
			case FLYPackage.FOR_EXPRESSION:
				sequence_ForExpression(context, (ForExpression) semanticObject); 
				return; 
			case FLYPackage.FUNCTION_DEFINITION:
				sequence_FunctionDefinition(context, (FunctionDefinition) semanticObject); 
				return; 
			case FLYPackage.FUNCTION_INPUT:
				sequence_FunctionInput(context, (FunctionInput) semanticObject); 
				return; 
			case FLYPackage.FUNCTION_RETURN:
				sequence_FunctionReturn(context, (FunctionReturn) semanticObject); 
				return; 
			case FLYPackage.IF_EXPRESSION:
				sequence_IfExpression(context, (IfExpression) semanticObject); 
				return; 
			case FLYPackage.INDEX_OBJECT:
				sequence_ObjectLiteral(context, (IndexObject) semanticObject); 
				return; 
			case FLYPackage.LOCAL_FUNCTION_CALL:
				sequence_LocalFunctionCall(context, (LocalFunctionCall) semanticObject); 
				return; 
			case FLYPackage.LOCAL_FUNCTION_INPUT:
				sequence_LocalFunctionInput(context, (LocalFunctionInput) semanticObject); 
				return; 
			case FLYPackage.MATH_FUNCTION:
				sequence_MathFunction(context, (MathFunction) semanticObject); 
				return; 
			case FLYPackage.NAME_OBJECT:
				sequence_ObjectLiteral(context, (NameObject) semanticObject); 
				return; 
			case FLYPackage.NAME_OBJECT_DEF:
				sequence_Object(context, (NameObjectDef) semanticObject); 
				return; 
			case FLYPackage.NUMBER_LITERAL:
				sequence_NumberLiteral(context, (NumberLiteral) semanticObject); 
				return; 
			case FLYPackage.OPTIMIZER_DECLARATION:
				sequence_VariableDeclaration(context, (OptimizerDeclaration) semanticObject); 
				return; 
			case FLYPackage.PARENTHESIZED_EXPRESSION:
				sequence_ParenthesizedExpression(context, (ParenthesizedExpression) semanticObject); 
				return; 
			case FLYPackage.POSTFIX_OPERATION:
				sequence_PostfixOperation(context, (PostfixOperation) semanticObject); 
				return; 
			case FLYPackage.PRINT_EXPRESSION:
				sequence_PrintExpression(context, (PrintExpression) semanticObject); 
				return; 
			case FLYPackage.RANDOM_DECLARATION:
				sequence_VariableDeclaration(context, (RandomDeclaration) semanticObject); 
				return; 
			case FLYPackage.RANGE_LITERAL:
				sequence_RangeLiteral(context, (RangeLiteral) semanticObject); 
				return; 
			case FLYPackage.SORT_EXPRESSION:
				sequence_SortExpression(context, (SortExpression) semanticObject); 
				return; 
			case FLYPackage.STRING_LITERAL:
				sequence_StringLiteral(context, (StringLiteral) semanticObject); 
				return; 
			case FLYPackage.TIME_FUNCTION:
				sequence_TimeFunction(context, (TimeFunction) semanticObject); 
				return; 
			case FLYPackage.UNARY_OPERATION:
				sequence_UnaryOperation(context, (UnaryOperation) semanticObject); 
				return; 
			case FLYPackage.VARIABLE_DECLARATION:
				if (rule == grammarAccess.getParamsRule()) {
					sequence_Params(context, (VariableDeclaration) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getVariableDeclarationRule()) {
					sequence_VariableDeclaration(context, (VariableDeclaration) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getVariableForRule()) {
					sequence_VariableFor(context, (VariableDeclaration) semanticObject); 
					return; 
				}
				else break;
			case FLYPackage.VARIABLE_FUNCTION:
				sequence_VariableFunction(context, (VariableFunction) semanticObject); 
				return; 
			case FLYPackage.VARIABLE_LITERAL:
				sequence_VariableLiteral(context, (VariableLiteral) semanticObject); 
				return; 
			case FLYPackage.WHILE_EXPRESSION:
				sequence_WhileExpression(context, (WhileExpression) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     ArithmeticExpression returns BinaryOperation
	 *     OrExpression returns BinaryOperation
	 *     OrExpression.BinaryOperation_1_0_0_0 returns BinaryOperation
	 *
	 * Constraint:
	 *     (
	 *         (left=OrExpression_BinaryOperation_1_0_0_0 feature=OpOr right=AndExpression) | 
	 *         (left=AndExpression_BinaryOperation_1_0_0_0 feature=OpAnd right=EqualityExpression) | 
	 *         (left=EqualityExpression_BinaryOperation_1_0_0_0 feature=OpEquality right=RelationalExpression) | 
	 *         (left=RelationalExpression_BinaryOperation_1_0_0_0 feature=OpCompare right=AdditiveExpression) | 
	 *         (left=AdditiveExpression_BinaryOperation_1_0_0_0 feature=OpAdd right=MultiplicativeExpression) | 
	 *         (left=MultiplicativeExpression_BinaryOperation_1_0_0_0 feature=OpMulti right=UnaryOperation)
	 *     )
	 */
	protected void sequence_AdditiveExpression_AndExpression_EqualityExpression_MultiplicativeExpression_OrExpression_RelationalExpression(ISerializationContext context, BinaryOperation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AndExpression returns BinaryOperation
	 *     AndExpression.BinaryOperation_1_0_0_0 returns BinaryOperation
	 *
	 * Constraint:
	 *     (
	 *         (left=AndExpression_BinaryOperation_1_0_0_0 feature=OpAnd right=EqualityExpression) | 
	 *         (left=EqualityExpression_BinaryOperation_1_0_0_0 feature=OpEquality right=RelationalExpression) | 
	 *         (left=RelationalExpression_BinaryOperation_1_0_0_0 feature=OpCompare right=AdditiveExpression) | 
	 *         (left=AdditiveExpression_BinaryOperation_1_0_0_0 feature=OpAdd right=MultiplicativeExpression) | 
	 *         (left=MultiplicativeExpression_BinaryOperation_1_0_0_0 feature=OpMulti right=UnaryOperation)
	 *     )
	 */
	protected void sequence_AdditiveExpression_AndExpression_EqualityExpression_MultiplicativeExpression_RelationalExpression(ISerializationContext context, BinaryOperation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EqualityExpression returns BinaryOperation
	 *     EqualityExpression.BinaryOperation_1_0_0_0 returns BinaryOperation
	 *
	 * Constraint:
	 *     (
	 *         (left=EqualityExpression_BinaryOperation_1_0_0_0 feature=OpEquality right=RelationalExpression) | 
	 *         (left=RelationalExpression_BinaryOperation_1_0_0_0 feature=OpCompare right=AdditiveExpression) | 
	 *         (left=AdditiveExpression_BinaryOperation_1_0_0_0 feature=OpAdd right=MultiplicativeExpression) | 
	 *         (left=MultiplicativeExpression_BinaryOperation_1_0_0_0 feature=OpMulti right=UnaryOperation)
	 *     )
	 */
	protected void sequence_AdditiveExpression_EqualityExpression_MultiplicativeExpression_RelationalExpression(ISerializationContext context, BinaryOperation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AdditiveExpression returns BinaryOperation
	 *     AdditiveExpression.BinaryOperation_1_0_0_0 returns BinaryOperation
	 *
	 * Constraint:
	 *     (
	 *         (left=AdditiveExpression_BinaryOperation_1_0_0_0 feature=OpAdd right=MultiplicativeExpression) | 
	 *         (left=MultiplicativeExpression_BinaryOperation_1_0_0_0 feature=OpMulti right=UnaryOperation)
	 *     )
	 */
	protected void sequence_AdditiveExpression_MultiplicativeExpression(ISerializationContext context, BinaryOperation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RelationalExpression returns BinaryOperation
	 *     RelationalExpression.BinaryOperation_1_0_0_0 returns BinaryOperation
	 *
	 * Constraint:
	 *     (
	 *         (left=RelationalExpression_BinaryOperation_1_0_0_0 feature=OpCompare right=AdditiveExpression) | 
	 *         (left=AdditiveExpression_BinaryOperation_1_0_0_0 feature=OpAdd right=MultiplicativeExpression) | 
	 *         (left=MultiplicativeExpression_BinaryOperation_1_0_0_0 feature=OpMulti right=UnaryOperation)
	 *     )
	 */
	protected void sequence_AdditiveExpression_MultiplicativeExpression_RelationalExpression(ISerializationContext context, BinaryOperation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Assignment
	 *     Assignment returns Assignment
	 *
	 * Constraint:
	 *     ((feature=VariableLiteral op=OpAs value=ArithmeticExpression) | (feature_obj=ObjectLiteral op=OpAs value=ArithmeticExpression))
	 */
	protected void sequence_Assignment(ISerializationContext context, Assignment semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns AtomicExpression
	 *     AtomicExpression returns AtomicExpression
	 *
	 * Constraint:
	 *     expressions=BlockExpression
	 */
	protected void sequence_AtomicExpression(ISerializationContext context, AtomicExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FLYPackage.Literals.ATOMIC_EXPRESSION__EXPRESSIONS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FLYPackage.Literals.ATOMIC_EXPRESSION__EXPRESSIONS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicExpressionAccess().getExpressionsBlockExpressionParserRuleCall_1_0(), semanticObject.getExpressions());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns BlockExpression
	 *     BlockExpression returns BlockExpression
	 *
	 * Constraint:
	 *     expressions+=Expression*
	 */
	protected void sequence_BlockExpression(ISerializationContext context, BlockExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ArithmeticExpression returns BooleanLiteral
	 *     OrExpression returns BooleanLiteral
	 *     OrExpression.BinaryOperation_1_0_0_0 returns BooleanLiteral
	 *     AndExpression returns BooleanLiteral
	 *     AndExpression.BinaryOperation_1_0_0_0 returns BooleanLiteral
	 *     EqualityExpression returns BooleanLiteral
	 *     EqualityExpression.BinaryOperation_1_0_0_0 returns BooleanLiteral
	 *     RelationalExpression returns BooleanLiteral
	 *     RelationalExpression.BinaryOperation_1_0_0_0 returns BooleanLiteral
	 *     AdditiveExpression returns BooleanLiteral
	 *     AdditiveExpression.BinaryOperation_1_0_0_0 returns BooleanLiteral
	 *     MultiplicativeExpression returns BooleanLiteral
	 *     MultiplicativeExpression.BinaryOperation_1_0_0_0 returns BooleanLiteral
	 *     UnaryOperation returns BooleanLiteral
	 *     CastExpression returns BooleanLiteral
	 *     CastExpression.CastExpression_1_0_0_0 returns BooleanLiteral
	 *     PostfixOperation returns BooleanLiteral
	 *     PostfixOperation.PostfixOperation_1_0_0 returns BooleanLiteral
	 *     PrimaryExpression returns BooleanLiteral
	 *     LiteralExpression returns BooleanLiteral
	 *     BooleanLiteral returns BooleanLiteral
	 *
	 * Constraint:
	 *     (value='false' | value='true')
	 */
	protected void sequence_BooleanLiteral(ISerializationContext context, BooleanLiteral semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ArithmeticExpression returns CastExpression
	 *     OrExpression returns CastExpression
	 *     OrExpression.BinaryOperation_1_0_0_0 returns CastExpression
	 *     AndExpression returns CastExpression
	 *     AndExpression.BinaryOperation_1_0_0_0 returns CastExpression
	 *     EqualityExpression returns CastExpression
	 *     EqualityExpression.BinaryOperation_1_0_0_0 returns CastExpression
	 *     RelationalExpression returns CastExpression
	 *     RelationalExpression.BinaryOperation_1_0_0_0 returns CastExpression
	 *     AdditiveExpression returns CastExpression
	 *     AdditiveExpression.BinaryOperation_1_0_0_0 returns CastExpression
	 *     MultiplicativeExpression returns CastExpression
	 *     MultiplicativeExpression.BinaryOperation_1_0_0_0 returns CastExpression
	 *     UnaryOperation returns CastExpression
	 *     CastExpression returns CastExpression
	 *     CastExpression.CastExpression_1_0_0_0 returns CastExpression
	 *
	 * Constraint:
	 *     (target=CastExpression_CastExpression_1_0_0_0 (op='as' | op='parse') type=Type)
	 */
	protected void sequence_CastExpression(ISerializationContext context, CastExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns ChannelReceive
	 *     ChannelReceive returns ChannelReceive
	 *     ArithmeticExpression returns ChannelReceive
	 *     OrExpression returns ChannelReceive
	 *     OrExpression.BinaryOperation_1_0_0_0 returns ChannelReceive
	 *     AndExpression returns ChannelReceive
	 *     AndExpression.BinaryOperation_1_0_0_0 returns ChannelReceive
	 *     EqualityExpression returns ChannelReceive
	 *     EqualityExpression.BinaryOperation_1_0_0_0 returns ChannelReceive
	 *     RelationalExpression returns ChannelReceive
	 *     RelationalExpression.BinaryOperation_1_0_0_0 returns ChannelReceive
	 *     AdditiveExpression returns ChannelReceive
	 *     AdditiveExpression.BinaryOperation_1_0_0_0 returns ChannelReceive
	 *     MultiplicativeExpression returns ChannelReceive
	 *     MultiplicativeExpression.BinaryOperation_1_0_0_0 returns ChannelReceive
	 *     UnaryOperation returns ChannelReceive
	 *     CastExpression returns ChannelReceive
	 *     CastExpression.CastExpression_1_0_0_0 returns ChannelReceive
	 *     PostfixOperation returns ChannelReceive
	 *     PostfixOperation.PostfixOperation_1_0_0 returns ChannelReceive
	 *     PrimaryExpression returns ChannelReceive
	 *
	 * Constraint:
	 *     target=[ChannelDeclaration|ID]
	 */
	protected void sequence_ChannelReceive(ISerializationContext context, ChannelReceive semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FLYPackage.Literals.CHANNEL_RECEIVE__TARGET) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FLYPackage.Literals.CHANNEL_RECEIVE__TARGET));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getChannelReceiveAccess().getTargetChannelDeclarationIDTerminalRuleCall_1_0_1(), semanticObject.eGet(FLYPackage.Literals.CHANNEL_RECEIVE__TARGET, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns ChannelSend
	 *     ChannelSend returns ChannelSend
	 *     ArithmeticExpression returns ChannelSend
	 *     OrExpression returns ChannelSend
	 *     OrExpression.BinaryOperation_1_0_0_0 returns ChannelSend
	 *     AndExpression returns ChannelSend
	 *     AndExpression.BinaryOperation_1_0_0_0 returns ChannelSend
	 *     EqualityExpression returns ChannelSend
	 *     EqualityExpression.BinaryOperation_1_0_0_0 returns ChannelSend
	 *     RelationalExpression returns ChannelSend
	 *     RelationalExpression.BinaryOperation_1_0_0_0 returns ChannelSend
	 *     AdditiveExpression returns ChannelSend
	 *     AdditiveExpression.BinaryOperation_1_0_0_0 returns ChannelSend
	 *     MultiplicativeExpression returns ChannelSend
	 *     MultiplicativeExpression.BinaryOperation_1_0_0_0 returns ChannelSend
	 *     UnaryOperation returns ChannelSend
	 *     CastExpression returns ChannelSend
	 *     CastExpression.CastExpression_1_0_0_0 returns ChannelSend
	 *     PostfixOperation returns ChannelSend
	 *     PostfixOperation.PostfixOperation_1_0_0 returns ChannelSend
	 *     PrimaryExpression returns ChannelSend
	 *
	 * Constraint:
	 *     (target=[ChannelDeclaration|ID] expression=ArithmeticExpression)
	 */
	protected void sequence_ChannelSend(ISerializationContext context, ChannelSend semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FLYPackage.Literals.CHANNEL_SEND__TARGET) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FLYPackage.Literals.CHANNEL_SEND__TARGET));
			if (transientValues.isValueTransient(semanticObject, FLYPackage.Literals.CHANNEL_SEND__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FLYPackage.Literals.CHANNEL_SEND__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getChannelSendAccess().getTargetChannelDeclarationIDTerminalRuleCall_1_0_1(), semanticObject.eGet(FLYPackage.Literals.CHANNEL_SEND__TARGET, false));
		feeder.accept(grammarAccess.getChannelSendAccess().getExpressionArithmeticExpressionParserRuleCall_3_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     DeclarationFeature returns DeclarationFeature
	 *
	 * Constraint:
	 *     (feature=ID (value_f=ID | value_s=STRING | value_t=INT | value_b=BooleanLiteral))
	 */
	protected void sequence_DeclarationFeature(ISerializationContext context, DeclarationFeature semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DeclarationObject returns DeclarationObject
	 *
	 * Constraint:
	 *     (features+=DeclarationFeature features+=DeclarationFeature*)
	 */
	protected void sequence_DeclarationObject(ISerializationContext context, DeclarationObject semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FeautureName returns FeautureName
	 *
	 * Constraint:
	 *     ((feature=ID value=ArithmeticExpression) | value=ArithmeticExpression)
	 */
	protected void sequence_FeautureName(ISerializationContext context, FeautureName semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ArithmeticExpression returns FloatLiteral
	 *     OrExpression returns FloatLiteral
	 *     OrExpression.BinaryOperation_1_0_0_0 returns FloatLiteral
	 *     AndExpression returns FloatLiteral
	 *     AndExpression.BinaryOperation_1_0_0_0 returns FloatLiteral
	 *     EqualityExpression returns FloatLiteral
	 *     EqualityExpression.BinaryOperation_1_0_0_0 returns FloatLiteral
	 *     RelationalExpression returns FloatLiteral
	 *     RelationalExpression.BinaryOperation_1_0_0_0 returns FloatLiteral
	 *     AdditiveExpression returns FloatLiteral
	 *     AdditiveExpression.BinaryOperation_1_0_0_0 returns FloatLiteral
	 *     MultiplicativeExpression returns FloatLiteral
	 *     MultiplicativeExpression.BinaryOperation_1_0_0_0 returns FloatLiteral
	 *     UnaryOperation returns FloatLiteral
	 *     CastExpression returns FloatLiteral
	 *     CastExpression.CastExpression_1_0_0_0 returns FloatLiteral
	 *     PostfixOperation returns FloatLiteral
	 *     PostfixOperation.PostfixOperation_1_0_0 returns FloatLiteral
	 *     PrimaryExpression returns FloatLiteral
	 *     LiteralExpression returns FloatLiteral
	 *     FloatLiteral returns FloatLiteral
	 *
	 * Constraint:
	 *     value=FLOAT
	 */
	protected void sequence_FloatLiteral(ISerializationContext context, FloatLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FLYPackage.Literals.FLOAT_LITERAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FLYPackage.Literals.FLOAT_LITERAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFloatLiteralAccess().getValueFLOATTerminalRuleCall_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns FlyFunctionCall
	 *     FlyFunctionCall returns FlyFunctionCall
	 *
	 * Constraint:
	 *     (
	 *         isAsync?='async'? 
	 *         target=[FunctionDefinition|ID] 
	 *         input=FunctionInput? 
	 *         environment=[EnvironmentDeclaration|ID] 
	 *         (is_then?='then' then=[FunctionDefinition|ID])? 
	 *         (is_thenall?='thenall' thenall=[FunctionDefinition|ID])?
	 *     )
	 */
	protected void sequence_FlyFunctionCall(ISerializationContext context, FlyFunctionCall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Fly returns Fly
	 *
	 * Constraint:
	 *     elements+=Expression+
	 */
	protected void sequence_Fly(ISerializationContext context, Fly semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns ForExpression
	 *     ForExpression returns ForExpression
	 *
	 * Constraint:
	 *     (index=VariableFor object=ArithmeticExpression body=Expression)
	 */
	protected void sequence_ForExpression(ISerializationContext context, ForExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FLYPackage.Literals.FOR_EXPRESSION__INDEX) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FLYPackage.Literals.FOR_EXPRESSION__INDEX));
			if (transientValues.isValueTransient(semanticObject, FLYPackage.Literals.FOR_EXPRESSION__OBJECT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FLYPackage.Literals.FOR_EXPRESSION__OBJECT));
			if (transientValues.isValueTransient(semanticObject, FLYPackage.Literals.FOR_EXPRESSION__BODY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FLYPackage.Literals.FOR_EXPRESSION__BODY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getForExpressionAccess().getIndexVariableForParserRuleCall_2_0(), semanticObject.getIndex());
		feeder.accept(grammarAccess.getForExpressionAccess().getObjectArithmeticExpressionParserRuleCall_4_0(), semanticObject.getObject());
		feeder.accept(grammarAccess.getForExpressionAccess().getBodyExpressionParserRuleCall_5_0(), semanticObject.getBody());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns FunctionDefinition
	 *     FunctionDefinition returns FunctionDefinition
	 *
	 * Constraint:
	 *     (name=ID parameters+=Params? parameters+=Params* body=BlockExpression)
	 */
	protected void sequence_FunctionDefinition(ISerializationContext context, FunctionDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FunctionInput returns FunctionInput
	 *
	 * Constraint:
	 *     ((expressions+=ArithmeticExpression? expressions+=ArithmeticExpression*) | (is_for_index?='in' f_index=ArithmeticExpression))
	 */
	protected void sequence_FunctionInput(ISerializationContext context, FunctionInput semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns FunctionReturn
	 *     FunctionReturn returns FunctionReturn
	 *
	 * Constraint:
	 *     expression=ArithmeticExpression
	 */
	protected void sequence_FunctionReturn(ISerializationContext context, FunctionReturn semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FLYPackage.Literals.FUNCTION_RETURN__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FLYPackage.Literals.FUNCTION_RETURN__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFunctionReturnAccess().getExpressionArithmeticExpressionParserRuleCall_2_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns IfExpression
	 *     IfExpression returns IfExpression
	 *
	 * Constraint:
	 *     (cond=ArithmeticExpression then=Expression else=Expression?)
	 */
	protected void sequence_IfExpression(ISerializationContext context, IfExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns LocalFunctionCall
	 *     LocalFunctionCall returns LocalFunctionCall
	 *     ArithmeticExpression returns LocalFunctionCall
	 *     OrExpression returns LocalFunctionCall
	 *     OrExpression.BinaryOperation_1_0_0_0 returns LocalFunctionCall
	 *     AndExpression returns LocalFunctionCall
	 *     AndExpression.BinaryOperation_1_0_0_0 returns LocalFunctionCall
	 *     EqualityExpression returns LocalFunctionCall
	 *     EqualityExpression.BinaryOperation_1_0_0_0 returns LocalFunctionCall
	 *     RelationalExpression returns LocalFunctionCall
	 *     RelationalExpression.BinaryOperation_1_0_0_0 returns LocalFunctionCall
	 *     AdditiveExpression returns LocalFunctionCall
	 *     AdditiveExpression.BinaryOperation_1_0_0_0 returns LocalFunctionCall
	 *     MultiplicativeExpression returns LocalFunctionCall
	 *     MultiplicativeExpression.BinaryOperation_1_0_0_0 returns LocalFunctionCall
	 *     UnaryOperation returns LocalFunctionCall
	 *     CastExpression returns LocalFunctionCall
	 *     CastExpression.CastExpression_1_0_0_0 returns LocalFunctionCall
	 *     PostfixOperation returns LocalFunctionCall
	 *     PostfixOperation.PostfixOperation_1_0_0 returns LocalFunctionCall
	 *     PrimaryExpression returns LocalFunctionCall
	 *
	 * Constraint:
	 *     (target=[FunctionDefinition|ID] input=LocalFunctionInput)
	 */
	protected void sequence_LocalFunctionCall(ISerializationContext context, LocalFunctionCall semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FLYPackage.Literals.LOCAL_FUNCTION_CALL__TARGET) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FLYPackage.Literals.LOCAL_FUNCTION_CALL__TARGET));
			if (transientValues.isValueTransient(semanticObject, FLYPackage.Literals.LOCAL_FUNCTION_CALL__INPUT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FLYPackage.Literals.LOCAL_FUNCTION_CALL__INPUT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLocalFunctionCallAccess().getTargetFunctionDefinitionIDTerminalRuleCall_1_0_1(), semanticObject.eGet(FLYPackage.Literals.LOCAL_FUNCTION_CALL__TARGET, false));
		feeder.accept(grammarAccess.getLocalFunctionCallAccess().getInputLocalFunctionInputParserRuleCall_3_0(), semanticObject.getInput());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     LocalFunctionInput returns LocalFunctionInput
	 *
	 * Constraint:
	 *     (inputs+=ArithmeticExpression? inputs+=ArithmeticExpression*)
	 */
	protected void sequence_LocalFunctionInput(ISerializationContext context, LocalFunctionInput semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MathFunction returns MathFunction
	 *     ArithmeticExpression returns MathFunction
	 *     OrExpression returns MathFunction
	 *     OrExpression.BinaryOperation_1_0_0_0 returns MathFunction
	 *     AndExpression returns MathFunction
	 *     AndExpression.BinaryOperation_1_0_0_0 returns MathFunction
	 *     EqualityExpression returns MathFunction
	 *     EqualityExpression.BinaryOperation_1_0_0_0 returns MathFunction
	 *     RelationalExpression returns MathFunction
	 *     RelationalExpression.BinaryOperation_1_0_0_0 returns MathFunction
	 *     AdditiveExpression returns MathFunction
	 *     AdditiveExpression.BinaryOperation_1_0_0_0 returns MathFunction
	 *     MultiplicativeExpression returns MathFunction
	 *     MultiplicativeExpression.BinaryOperation_1_0_0_0 returns MathFunction
	 *     UnaryOperation returns MathFunction
	 *     CastExpression returns MathFunction
	 *     CastExpression.CastExpression_1_0_0_0 returns MathFunction
	 *     PostfixOperation returns MathFunction
	 *     PostfixOperation.PostfixOperation_1_0_0 returns MathFunction
	 *     PrimaryExpression returns MathFunction
	 *
	 * Constraint:
	 *     (feature=ID expressions+=ArithmeticExpression? expressions+=ArithmeticExpression*)
	 */
	protected void sequence_MathFunction(ISerializationContext context, MathFunction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MultiplicativeExpression returns BinaryOperation
	 *     MultiplicativeExpression.BinaryOperation_1_0_0_0 returns BinaryOperation
	 *
	 * Constraint:
	 *     (left=MultiplicativeExpression_BinaryOperation_1_0_0_0 feature=OpMulti right=UnaryOperation)
	 */
	protected void sequence_MultiplicativeExpression(ISerializationContext context, BinaryOperation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FLYPackage.Literals.BINARY_OPERATION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FLYPackage.Literals.BINARY_OPERATION__LEFT));
			if (transientValues.isValueTransient(semanticObject, FLYPackage.Literals.BINARY_OPERATION__FEATURE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FLYPackage.Literals.BINARY_OPERATION__FEATURE));
			if (transientValues.isValueTransient(semanticObject, FLYPackage.Literals.BINARY_OPERATION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FLYPackage.Literals.BINARY_OPERATION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMultiplicativeExpressionAccess().getBinaryOperationLeftAction_1_0_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getMultiplicativeExpressionAccess().getFeatureOpMultiParserRuleCall_1_0_0_1_0(), semanticObject.getFeature());
		feeder.accept(grammarAccess.getMultiplicativeExpressionAccess().getRightUnaryOperationParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ArithmeticExpression returns NumberLiteral
	 *     OrExpression returns NumberLiteral
	 *     OrExpression.BinaryOperation_1_0_0_0 returns NumberLiteral
	 *     AndExpression returns NumberLiteral
	 *     AndExpression.BinaryOperation_1_0_0_0 returns NumberLiteral
	 *     EqualityExpression returns NumberLiteral
	 *     EqualityExpression.BinaryOperation_1_0_0_0 returns NumberLiteral
	 *     RelationalExpression returns NumberLiteral
	 *     RelationalExpression.BinaryOperation_1_0_0_0 returns NumberLiteral
	 *     AdditiveExpression returns NumberLiteral
	 *     AdditiveExpression.BinaryOperation_1_0_0_0 returns NumberLiteral
	 *     MultiplicativeExpression returns NumberLiteral
	 *     MultiplicativeExpression.BinaryOperation_1_0_0_0 returns NumberLiteral
	 *     UnaryOperation returns NumberLiteral
	 *     CastExpression returns NumberLiteral
	 *     CastExpression.CastExpression_1_0_0_0 returns NumberLiteral
	 *     PostfixOperation returns NumberLiteral
	 *     PostfixOperation.PostfixOperation_1_0_0 returns NumberLiteral
	 *     PrimaryExpression returns NumberLiteral
	 *     LiteralExpression returns NumberLiteral
	 *     NumberLiteral returns NumberLiteral
	 *
	 * Constraint:
	 *     value=INT
	 */
	protected void sequence_NumberLiteral(ISerializationContext context, NumberLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FLYPackage.Literals.NUMBER_LITERAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FLYPackage.Literals.NUMBER_LITERAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNumberLiteralAccess().getValueINTTerminalRuleCall_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ObjectLiteral returns DatSingleObject
	 *     ArithmeticExpression returns DatSingleObject
	 *     OrExpression returns DatSingleObject
	 *     OrExpression.BinaryOperation_1_0_0_0 returns DatSingleObject
	 *     AndExpression returns DatSingleObject
	 *     AndExpression.BinaryOperation_1_0_0_0 returns DatSingleObject
	 *     EqualityExpression returns DatSingleObject
	 *     EqualityExpression.BinaryOperation_1_0_0_0 returns DatSingleObject
	 *     RelationalExpression returns DatSingleObject
	 *     RelationalExpression.BinaryOperation_1_0_0_0 returns DatSingleObject
	 *     AdditiveExpression returns DatSingleObject
	 *     AdditiveExpression.BinaryOperation_1_0_0_0 returns DatSingleObject
	 *     MultiplicativeExpression returns DatSingleObject
	 *     MultiplicativeExpression.BinaryOperation_1_0_0_0 returns DatSingleObject
	 *     UnaryOperation returns DatSingleObject
	 *     CastExpression returns DatSingleObject
	 *     CastExpression.CastExpression_1_0_0_0 returns DatSingleObject
	 *     PostfixOperation returns DatSingleObject
	 *     PostfixOperation.PostfixOperation_1_0_0 returns DatSingleObject
	 *     PrimaryExpression returns DatSingleObject
	 *     LiteralExpression returns DatSingleObject
	 *
	 * Constraint:
	 *     (name=[VariableDeclaration|ID] (value1=NumberLiteral | value1=StringLiteral) (value2=NumberLiteral | value2=StringLiteral))
	 */
	protected void sequence_ObjectLiteral(ISerializationContext context, DatSingleObject semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ObjectLiteral returns DatTableObject
	 *     ArithmeticExpression returns DatTableObject
	 *     OrExpression returns DatTableObject
	 *     OrExpression.BinaryOperation_1_0_0_0 returns DatTableObject
	 *     AndExpression returns DatTableObject
	 *     AndExpression.BinaryOperation_1_0_0_0 returns DatTableObject
	 *     EqualityExpression returns DatTableObject
	 *     EqualityExpression.BinaryOperation_1_0_0_0 returns DatTableObject
	 *     RelationalExpression returns DatTableObject
	 *     RelationalExpression.BinaryOperation_1_0_0_0 returns DatTableObject
	 *     AdditiveExpression returns DatTableObject
	 *     AdditiveExpression.BinaryOperation_1_0_0_0 returns DatTableObject
	 *     MultiplicativeExpression returns DatTableObject
	 *     MultiplicativeExpression.BinaryOperation_1_0_0_0 returns DatTableObject
	 *     UnaryOperation returns DatTableObject
	 *     CastExpression returns DatTableObject
	 *     CastExpression.CastExpression_1_0_0_0 returns DatTableObject
	 *     PostfixOperation returns DatTableObject
	 *     PostfixOperation.PostfixOperation_1_0_0 returns DatTableObject
	 *     PrimaryExpression returns DatTableObject
	 *     LiteralExpression returns DatTableObject
	 *
	 * Constraint:
	 *     (name=[VariableDeclaration|ID] (range1=RangeLiteral | range1_t=NumberLiteral) range2=RangeLiteral)
	 */
	protected void sequence_ObjectLiteral(ISerializationContext context, DatTableObject semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ObjectLiteral returns IndexObject
	 *     ArithmeticExpression returns IndexObject
	 *     OrExpression returns IndexObject
	 *     OrExpression.BinaryOperation_1_0_0_0 returns IndexObject
	 *     AndExpression returns IndexObject
	 *     AndExpression.BinaryOperation_1_0_0_0 returns IndexObject
	 *     EqualityExpression returns IndexObject
	 *     EqualityExpression.BinaryOperation_1_0_0_0 returns IndexObject
	 *     RelationalExpression returns IndexObject
	 *     RelationalExpression.BinaryOperation_1_0_0_0 returns IndexObject
	 *     AdditiveExpression returns IndexObject
	 *     AdditiveExpression.BinaryOperation_1_0_0_0 returns IndexObject
	 *     MultiplicativeExpression returns IndexObject
	 *     MultiplicativeExpression.BinaryOperation_1_0_0_0 returns IndexObject
	 *     UnaryOperation returns IndexObject
	 *     CastExpression returns IndexObject
	 *     CastExpression.CastExpression_1_0_0_0 returns IndexObject
	 *     PostfixOperation returns IndexObject
	 *     PostfixOperation.PostfixOperation_1_0_0 returns IndexObject
	 *     PrimaryExpression returns IndexObject
	 *     LiteralExpression returns IndexObject
	 *
	 * Constraint:
	 *     ((name=[VariableDeclaration|ID] valuet=INT) | (name=[VariableDeclaration|ID] value=[VariableDeclaration|ID]))
	 */
	protected void sequence_ObjectLiteral(ISerializationContext context, IndexObject semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ObjectLiteral returns NameObject
	 *     ArithmeticExpression returns NameObject
	 *     OrExpression returns NameObject
	 *     OrExpression.BinaryOperation_1_0_0_0 returns NameObject
	 *     AndExpression returns NameObject
	 *     AndExpression.BinaryOperation_1_0_0_0 returns NameObject
	 *     EqualityExpression returns NameObject
	 *     EqualityExpression.BinaryOperation_1_0_0_0 returns NameObject
	 *     RelationalExpression returns NameObject
	 *     RelationalExpression.BinaryOperation_1_0_0_0 returns NameObject
	 *     AdditiveExpression returns NameObject
	 *     AdditiveExpression.BinaryOperation_1_0_0_0 returns NameObject
	 *     MultiplicativeExpression returns NameObject
	 *     MultiplicativeExpression.BinaryOperation_1_0_0_0 returns NameObject
	 *     UnaryOperation returns NameObject
	 *     CastExpression returns NameObject
	 *     CastExpression.CastExpression_1_0_0_0 returns NameObject
	 *     PostfixOperation returns NameObject
	 *     PostfixOperation.PostfixOperation_1_0_0 returns NameObject
	 *     PrimaryExpression returns NameObject
	 *     LiteralExpression returns NameObject
	 *
	 * Constraint:
	 *     (name=[VariableDeclaration|ID] value=ID)
	 */
	protected void sequence_ObjectLiteral(ISerializationContext context, NameObject semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FLYPackage.Literals.OBJECT_LITERAL__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FLYPackage.Literals.OBJECT_LITERAL__NAME));
			if (transientValues.isValueTransient(semanticObject, FLYPackage.Literals.NAME_OBJECT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FLYPackage.Literals.NAME_OBJECT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getObjectLiteralAccess().getNameVariableDeclarationIDTerminalRuleCall_0_1_0_1(), semanticObject.eGet(FLYPackage.Literals.OBJECT_LITERAL__NAME, false));
		feeder.accept(grammarAccess.getObjectLiteralAccess().getValueIDTerminalRuleCall_0_2_0_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Object returns NameObjectDef
	 *
	 * Constraint:
	 *     (features+=FeautureName? features+=FeautureName*)
	 */
	protected void sequence_Object(ISerializationContext context, NameObjectDef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Params returns VariableDeclaration
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_Params(ISerializationContext context, VariableDeclaration semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FLYPackage.Literals.VARIABLE_DECLARATION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FLYPackage.Literals.VARIABLE_DECLARATION__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getParamsAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ArithmeticExpression returns ParenthesizedExpression
	 *     OrExpression returns ParenthesizedExpression
	 *     OrExpression.BinaryOperation_1_0_0_0 returns ParenthesizedExpression
	 *     AndExpression returns ParenthesizedExpression
	 *     AndExpression.BinaryOperation_1_0_0_0 returns ParenthesizedExpression
	 *     EqualityExpression returns ParenthesizedExpression
	 *     EqualityExpression.BinaryOperation_1_0_0_0 returns ParenthesizedExpression
	 *     RelationalExpression returns ParenthesizedExpression
	 *     RelationalExpression.BinaryOperation_1_0_0_0 returns ParenthesizedExpression
	 *     AdditiveExpression returns ParenthesizedExpression
	 *     AdditiveExpression.BinaryOperation_1_0_0_0 returns ParenthesizedExpression
	 *     MultiplicativeExpression returns ParenthesizedExpression
	 *     MultiplicativeExpression.BinaryOperation_1_0_0_0 returns ParenthesizedExpression
	 *     UnaryOperation returns ParenthesizedExpression
	 *     CastExpression returns ParenthesizedExpression
	 *     CastExpression.CastExpression_1_0_0_0 returns ParenthesizedExpression
	 *     PostfixOperation returns ParenthesizedExpression
	 *     PostfixOperation.PostfixOperation_1_0_0 returns ParenthesizedExpression
	 *     PrimaryExpression returns ParenthesizedExpression
	 *     ParenthesizedExpression returns ParenthesizedExpression
	 *
	 * Constraint:
	 *     expression=ArithmeticExpression
	 */
	protected void sequence_ParenthesizedExpression(ISerializationContext context, ParenthesizedExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FLYPackage.Literals.PARENTHESIZED_EXPRESSION__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FLYPackage.Literals.PARENTHESIZED_EXPRESSION__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getParenthesizedExpressionAccess().getExpressionArithmeticExpressionParserRuleCall_2_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ArithmeticExpression returns PostfixOperation
	 *     OrExpression returns PostfixOperation
	 *     OrExpression.BinaryOperation_1_0_0_0 returns PostfixOperation
	 *     AndExpression returns PostfixOperation
	 *     AndExpression.BinaryOperation_1_0_0_0 returns PostfixOperation
	 *     EqualityExpression returns PostfixOperation
	 *     EqualityExpression.BinaryOperation_1_0_0_0 returns PostfixOperation
	 *     RelationalExpression returns PostfixOperation
	 *     RelationalExpression.BinaryOperation_1_0_0_0 returns PostfixOperation
	 *     AdditiveExpression returns PostfixOperation
	 *     AdditiveExpression.BinaryOperation_1_0_0_0 returns PostfixOperation
	 *     MultiplicativeExpression returns PostfixOperation
	 *     MultiplicativeExpression.BinaryOperation_1_0_0_0 returns PostfixOperation
	 *     UnaryOperation returns PostfixOperation
	 *     CastExpression returns PostfixOperation
	 *     CastExpression.CastExpression_1_0_0_0 returns PostfixOperation
	 *     PostfixOperation returns PostfixOperation
	 *
	 * Constraint:
	 *     (operand=PostfixOperation_PostfixOperation_1_0_0 feature=OpPostfix)
	 */
	protected void sequence_PostfixOperation(ISerializationContext context, PostfixOperation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FLYPackage.Literals.POSTFIX_OPERATION__OPERAND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FLYPackage.Literals.POSTFIX_OPERATION__OPERAND));
			if (transientValues.isValueTransient(semanticObject, FLYPackage.Literals.POSTFIX_OPERATION__FEATURE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FLYPackage.Literals.POSTFIX_OPERATION__FEATURE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPostfixOperationAccess().getPostfixOperationOperandAction_1_0_0(), semanticObject.getOperand());
		feeder.accept(grammarAccess.getPostfixOperationAccess().getFeatureOpPostfixParserRuleCall_1_0_1_0(), semanticObject.getFeature());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns PrintExpression
	 *     PrintExpression returns PrintExpression
	 *
	 * Constraint:
	 *     print=ArithmeticExpression
	 */
	protected void sequence_PrintExpression(ISerializationContext context, PrintExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FLYPackage.Literals.PRINT_EXPRESSION__PRINT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FLYPackage.Literals.PRINT_EXPRESSION__PRINT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPrintExpressionAccess().getPrintArithmeticExpressionParserRuleCall_2_0(), semanticObject.getPrint());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     RangeLiteral returns RangeLiteral
	 *     ArithmeticExpression returns RangeLiteral
	 *     OrExpression returns RangeLiteral
	 *     OrExpression.BinaryOperation_1_0_0_0 returns RangeLiteral
	 *     AndExpression returns RangeLiteral
	 *     AndExpression.BinaryOperation_1_0_0_0 returns RangeLiteral
	 *     EqualityExpression returns RangeLiteral
	 *     EqualityExpression.BinaryOperation_1_0_0_0 returns RangeLiteral
	 *     RelationalExpression returns RangeLiteral
	 *     RelationalExpression.BinaryOperation_1_0_0_0 returns RangeLiteral
	 *     AdditiveExpression returns RangeLiteral
	 *     AdditiveExpression.BinaryOperation_1_0_0_0 returns RangeLiteral
	 *     MultiplicativeExpression returns RangeLiteral
	 *     MultiplicativeExpression.BinaryOperation_1_0_0_0 returns RangeLiteral
	 *     UnaryOperation returns RangeLiteral
	 *     CastExpression returns RangeLiteral
	 *     CastExpression.CastExpression_1_0_0_0 returns RangeLiteral
	 *     PostfixOperation returns RangeLiteral
	 *     PostfixOperation.PostfixOperation_1_0_0 returns RangeLiteral
	 *     PrimaryExpression returns RangeLiteral
	 *     LiteralExpression returns RangeLiteral
	 *
	 * Constraint:
	 *     (value1=INT value2=INT)
	 */
	protected void sequence_RangeLiteral(ISerializationContext context, RangeLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FLYPackage.Literals.RANGE_LITERAL__VALUE1) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FLYPackage.Literals.RANGE_LITERAL__VALUE1));
			if (transientValues.isValueTransient(semanticObject, FLYPackage.Literals.RANGE_LITERAL__VALUE2) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FLYPackage.Literals.RANGE_LITERAL__VALUE2));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRangeLiteralAccess().getValue1INTTerminalRuleCall_2_0(), semanticObject.getValue1());
		feeder.accept(grammarAccess.getRangeLiteralAccess().getValue2INTTerminalRuleCall_4_0(), semanticObject.getValue2());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns SortExpression
	 *     SortExpression returns SortExpression
	 *
	 * Constraint:
	 *     ((type='asc' | type='desc') target=[VariableDeclaration|ID] taget=ID)
	 */
	protected void sequence_SortExpression(ISerializationContext context, SortExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ArithmeticExpression returns StringLiteral
	 *     OrExpression returns StringLiteral
	 *     OrExpression.BinaryOperation_1_0_0_0 returns StringLiteral
	 *     AndExpression returns StringLiteral
	 *     AndExpression.BinaryOperation_1_0_0_0 returns StringLiteral
	 *     EqualityExpression returns StringLiteral
	 *     EqualityExpression.BinaryOperation_1_0_0_0 returns StringLiteral
	 *     RelationalExpression returns StringLiteral
	 *     RelationalExpression.BinaryOperation_1_0_0_0 returns StringLiteral
	 *     AdditiveExpression returns StringLiteral
	 *     AdditiveExpression.BinaryOperation_1_0_0_0 returns StringLiteral
	 *     MultiplicativeExpression returns StringLiteral
	 *     MultiplicativeExpression.BinaryOperation_1_0_0_0 returns StringLiteral
	 *     UnaryOperation returns StringLiteral
	 *     CastExpression returns StringLiteral
	 *     CastExpression.CastExpression_1_0_0_0 returns StringLiteral
	 *     PostfixOperation returns StringLiteral
	 *     PostfixOperation.PostfixOperation_1_0_0 returns StringLiteral
	 *     PrimaryExpression returns StringLiteral
	 *     LiteralExpression returns StringLiteral
	 *     StringLiteral returns StringLiteral
	 *
	 * Constraint:
	 *     value=STRING
	 */
	protected void sequence_StringLiteral(ISerializationContext context, StringLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FLYPackage.Literals.STRING_LITERAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FLYPackage.Literals.STRING_LITERAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStringLiteralAccess().getValueSTRINGTerminalRuleCall_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ArithmeticExpression returns TimeFunction
	 *     OrExpression returns TimeFunction
	 *     OrExpression.BinaryOperation_1_0_0_0 returns TimeFunction
	 *     AndExpression returns TimeFunction
	 *     AndExpression.BinaryOperation_1_0_0_0 returns TimeFunction
	 *     EqualityExpression returns TimeFunction
	 *     EqualityExpression.BinaryOperation_1_0_0_0 returns TimeFunction
	 *     RelationalExpression returns TimeFunction
	 *     RelationalExpression.BinaryOperation_1_0_0_0 returns TimeFunction
	 *     AdditiveExpression returns TimeFunction
	 *     AdditiveExpression.BinaryOperation_1_0_0_0 returns TimeFunction
	 *     MultiplicativeExpression returns TimeFunction
	 *     MultiplicativeExpression.BinaryOperation_1_0_0_0 returns TimeFunction
	 *     UnaryOperation returns TimeFunction
	 *     CastExpression returns TimeFunction
	 *     CastExpression.CastExpression_1_0_0_0 returns TimeFunction
	 *     PostfixOperation returns TimeFunction
	 *     PostfixOperation.PostfixOperation_1_0_0 returns TimeFunction
	 *     PrimaryExpression returns TimeFunction
	 *     TimeFunction returns TimeFunction
	 *
	 * Constraint:
	 *     value=[VariableDeclaration|ID]*
	 */
	protected void sequence_TimeFunction(ISerializationContext context, TimeFunction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ArithmeticExpression returns UnaryOperation
	 *     OrExpression returns UnaryOperation
	 *     OrExpression.BinaryOperation_1_0_0_0 returns UnaryOperation
	 *     AndExpression returns UnaryOperation
	 *     AndExpression.BinaryOperation_1_0_0_0 returns UnaryOperation
	 *     EqualityExpression returns UnaryOperation
	 *     EqualityExpression.BinaryOperation_1_0_0_0 returns UnaryOperation
	 *     RelationalExpression returns UnaryOperation
	 *     RelationalExpression.BinaryOperation_1_0_0_0 returns UnaryOperation
	 *     AdditiveExpression returns UnaryOperation
	 *     AdditiveExpression.BinaryOperation_1_0_0_0 returns UnaryOperation
	 *     MultiplicativeExpression returns UnaryOperation
	 *     MultiplicativeExpression.BinaryOperation_1_0_0_0 returns UnaryOperation
	 *     UnaryOperation returns UnaryOperation
	 *
	 * Constraint:
	 *     (feature=OpUnary operand=UnaryOperation)
	 */
	protected void sequence_UnaryOperation(ISerializationContext context, UnaryOperation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FLYPackage.Literals.UNARY_OPERATION__FEATURE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FLYPackage.Literals.UNARY_OPERATION__FEATURE));
			if (transientValues.isValueTransient(semanticObject, FLYPackage.Literals.UNARY_OPERATION__OPERAND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FLYPackage.Literals.UNARY_OPERATION__OPERAND));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUnaryOperationAccess().getFeatureOpUnaryParserRuleCall_0_1_0(), semanticObject.getFeature());
		feeder.accept(grammarAccess.getUnaryOperationAccess().getOperandUnaryOperationParserRuleCall_0_2_0(), semanticObject.getOperand());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns BinDeclaration
	 *     VariableDeclaration returns BinDeclaration
	 *
	 * Constraint:
	 *     (typeobject='bin' name=ID right=DeclarationObject)
	 */
	protected void sequence_VariableDeclaration(ISerializationContext context, BinDeclaration semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FLYPackage.Literals.VARIABLE_DECLARATION__TYPEOBJECT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FLYPackage.Literals.VARIABLE_DECLARATION__TYPEOBJECT));
			if (transientValues.isValueTransient(semanticObject, FLYPackage.Literals.VARIABLE_DECLARATION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FLYPackage.Literals.VARIABLE_DECLARATION__NAME));
			if (transientValues.isValueTransient(semanticObject, FLYPackage.Literals.VARIABLE_DECLARATION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FLYPackage.Literals.VARIABLE_DECLARATION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVariableDeclarationAccess().getTypeobjectBinKeyword_4_1_0(), semanticObject.getTypeobject());
		feeder.accept(grammarAccess.getVariableDeclarationAccess().getNameIDTerminalRuleCall_4_2_0_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getVariableDeclarationAccess().getRightDeclarationObjectParserRuleCall_4_2_0_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns ChannelDeclaration
	 *     VariableDeclaration returns ChannelDeclaration
	 *
	 * Constraint:
	 *     (typeobject='channel' name=ID environment=[EnvironmentDeclaration|ID])
	 */
	protected void sequence_VariableDeclaration(ISerializationContext context, ChannelDeclaration semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FLYPackage.Literals.VARIABLE_DECLARATION__TYPEOBJECT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FLYPackage.Literals.VARIABLE_DECLARATION__TYPEOBJECT));
			if (transientValues.isValueTransient(semanticObject, FLYPackage.Literals.VARIABLE_DECLARATION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FLYPackage.Literals.VARIABLE_DECLARATION__NAME));
			if (transientValues.isValueTransient(semanticObject, FLYPackage.Literals.CHANNEL_DECLARATION__ENVIRONMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FLYPackage.Literals.CHANNEL_DECLARATION__ENVIRONMENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVariableDeclarationAccess().getTypeobjectChannelKeyword_6_1_0(), semanticObject.getTypeobject());
		feeder.accept(grammarAccess.getVariableDeclarationAccess().getNameIDTerminalRuleCall_6_2_0_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getVariableDeclarationAccess().getEnvironmentEnvironmentDeclarationIDTerminalRuleCall_6_2_0_2_0_1(), semanticObject.eGet(FLYPackage.Literals.CHANNEL_DECLARATION__ENVIRONMENT, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns DatDeclaration
	 *     VariableDeclaration returns DatDeclaration
	 *
	 * Constraint:
	 *     (typeobject='dat' name=ID (right=ArithmeticExpression | right=Object))
	 */
	protected void sequence_VariableDeclaration(ISerializationContext context, DatDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns EnvironmentDeclaration
	 *     VariableDeclaration returns EnvironmentDeclaration
	 *
	 * Constraint:
	 *     (typeobject='env' name=ID right=DeclarationObject)
	 */
	protected void sequence_VariableDeclaration(ISerializationContext context, EnvironmentDeclaration semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FLYPackage.Literals.VARIABLE_DECLARATION__TYPEOBJECT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FLYPackage.Literals.VARIABLE_DECLARATION__TYPEOBJECT));
			if (transientValues.isValueTransient(semanticObject, FLYPackage.Literals.VARIABLE_DECLARATION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FLYPackage.Literals.VARIABLE_DECLARATION__NAME));
			if (transientValues.isValueTransient(semanticObject, FLYPackage.Literals.VARIABLE_DECLARATION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FLYPackage.Literals.VARIABLE_DECLARATION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVariableDeclarationAccess().getTypeobjectEnvKeyword_3_1_0(), semanticObject.getTypeobject());
		feeder.accept(grammarAccess.getVariableDeclarationAccess().getNameIDTerminalRuleCall_3_2_0_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getVariableDeclarationAccess().getRightDeclarationObjectParserRuleCall_3_2_0_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns OptimizerDeclaration
	 *     VariableDeclaration returns OptimizerDeclaration
	 *
	 * Constraint:
	 *     (typeobject='opt' name=ID right=DeclarationObject)
	 */
	protected void sequence_VariableDeclaration(ISerializationContext context, OptimizerDeclaration semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FLYPackage.Literals.VARIABLE_DECLARATION__TYPEOBJECT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FLYPackage.Literals.VARIABLE_DECLARATION__TYPEOBJECT));
			if (transientValues.isValueTransient(semanticObject, FLYPackage.Literals.VARIABLE_DECLARATION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FLYPackage.Literals.VARIABLE_DECLARATION__NAME));
			if (transientValues.isValueTransient(semanticObject, FLYPackage.Literals.VARIABLE_DECLARATION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FLYPackage.Literals.VARIABLE_DECLARATION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVariableDeclarationAccess().getTypeobjectOptKeyword_5_1_0(), semanticObject.getTypeobject());
		feeder.accept(grammarAccess.getVariableDeclarationAccess().getNameIDTerminalRuleCall_5_2_0_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getVariableDeclarationAccess().getRightDeclarationObjectParserRuleCall_5_2_0_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns RandomDeclaration
	 *     VariableDeclaration returns RandomDeclaration
	 *
	 * Constraint:
	 *     (typeobject='random' name=ID)
	 */
	protected void sequence_VariableDeclaration(ISerializationContext context, RandomDeclaration semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FLYPackage.Literals.VARIABLE_DECLARATION__TYPEOBJECT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FLYPackage.Literals.VARIABLE_DECLARATION__TYPEOBJECT));
			if (transientValues.isValueTransient(semanticObject, FLYPackage.Literals.VARIABLE_DECLARATION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FLYPackage.Literals.VARIABLE_DECLARATION__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVariableDeclarationAccess().getTypeobjectRandomKeyword_2_1_0(), semanticObject.getTypeobject());
		feeder.accept(grammarAccess.getVariableDeclarationAccess().getNameIDTerminalRuleCall_2_2_0_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns VariableDeclaration
	 *     VariableDeclaration returns VariableDeclaration
	 *
	 * Constraint:
	 *     (typeobject='var' name=ID (right=ArithmeticExpression | right=Object | right=FlyFunctionCall))
	 */
	protected void sequence_VariableDeclaration(ISerializationContext context, VariableDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VariableFor returns VariableDeclaration
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_VariableFor(ISerializationContext context, VariableDeclaration semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FLYPackage.Literals.VARIABLE_DECLARATION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FLYPackage.Literals.VARIABLE_DECLARATION__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVariableForAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns VariableFunction
	 *     VariableFunction returns VariableFunction
	 *     ArithmeticExpression returns VariableFunction
	 *     OrExpression returns VariableFunction
	 *     OrExpression.BinaryOperation_1_0_0_0 returns VariableFunction
	 *     AndExpression returns VariableFunction
	 *     AndExpression.BinaryOperation_1_0_0_0 returns VariableFunction
	 *     EqualityExpression returns VariableFunction
	 *     EqualityExpression.BinaryOperation_1_0_0_0 returns VariableFunction
	 *     RelationalExpression returns VariableFunction
	 *     RelationalExpression.BinaryOperation_1_0_0_0 returns VariableFunction
	 *     AdditiveExpression returns VariableFunction
	 *     AdditiveExpression.BinaryOperation_1_0_0_0 returns VariableFunction
	 *     MultiplicativeExpression returns VariableFunction
	 *     MultiplicativeExpression.BinaryOperation_1_0_0_0 returns VariableFunction
	 *     UnaryOperation returns VariableFunction
	 *     CastExpression returns VariableFunction
	 *     CastExpression.CastExpression_1_0_0_0 returns VariableFunction
	 *     PostfixOperation returns VariableFunction
	 *     PostfixOperation.PostfixOperation_1_0_0 returns VariableFunction
	 *     PrimaryExpression returns VariableFunction
	 *
	 * Constraint:
	 *     (target=[VariableDeclaration|ID] feature=ID expressions+=ArithmeticExpression? expressions+=ArithmeticExpression*)
	 */
	protected void sequence_VariableFunction(ISerializationContext context, VariableFunction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ArithmeticExpression returns VariableLiteral
	 *     OrExpression returns VariableLiteral
	 *     OrExpression.BinaryOperation_1_0_0_0 returns VariableLiteral
	 *     AndExpression returns VariableLiteral
	 *     AndExpression.BinaryOperation_1_0_0_0 returns VariableLiteral
	 *     EqualityExpression returns VariableLiteral
	 *     EqualityExpression.BinaryOperation_1_0_0_0 returns VariableLiteral
	 *     RelationalExpression returns VariableLiteral
	 *     RelationalExpression.BinaryOperation_1_0_0_0 returns VariableLiteral
	 *     AdditiveExpression returns VariableLiteral
	 *     AdditiveExpression.BinaryOperation_1_0_0_0 returns VariableLiteral
	 *     MultiplicativeExpression returns VariableLiteral
	 *     MultiplicativeExpression.BinaryOperation_1_0_0_0 returns VariableLiteral
	 *     UnaryOperation returns VariableLiteral
	 *     CastExpression returns VariableLiteral
	 *     CastExpression.CastExpression_1_0_0_0 returns VariableLiteral
	 *     PostfixOperation returns VariableLiteral
	 *     PostfixOperation.PostfixOperation_1_0_0 returns VariableLiteral
	 *     PrimaryExpression returns VariableLiteral
	 *     LiteralExpression returns VariableLiteral
	 *     VariableLiteral returns VariableLiteral
	 *
	 * Constraint:
	 *     variable=[VariableDeclaration|ID]
	 */
	protected void sequence_VariableLiteral(ISerializationContext context, VariableLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FLYPackage.Literals.VARIABLE_LITERAL__VARIABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FLYPackage.Literals.VARIABLE_LITERAL__VARIABLE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVariableLiteralAccess().getVariableVariableDeclarationIDTerminalRuleCall_1_0_1(), semanticObject.eGet(FLYPackage.Literals.VARIABLE_LITERAL__VARIABLE, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns WhileExpression
	 *     WhileExpression returns WhileExpression
	 *
	 * Constraint:
	 *     (cond=ArithmeticExpression body=Expression)
	 */
	protected void sequence_WhileExpression(ISerializationContext context, WhileExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FLYPackage.Literals.WHILE_EXPRESSION__COND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FLYPackage.Literals.WHILE_EXPRESSION__COND));
			if (transientValues.isValueTransient(semanticObject, FLYPackage.Literals.WHILE_EXPRESSION__BODY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FLYPackage.Literals.WHILE_EXPRESSION__BODY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getWhileExpressionAccess().getCondArithmeticExpressionParserRuleCall_3_0(), semanticObject.getCond());
		feeder.accept(grammarAccess.getWhileExpressionAccess().getBodyExpressionParserRuleCall_5_0(), semanticObject.getBody());
		feeder.finish();
	}
	
	
}
